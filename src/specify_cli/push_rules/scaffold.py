"""Push rules scaffolding for specify init.

This module provides push rules file generation and state directory setup
that is executed when users run `specify init`.
"""

from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

# Default push rules template content embedded here for reliability
# Can also be loaded from templates/push-rules-template.md
DEFAULT_PUSH_RULES_CONTENT = """---
# Push Rules Configuration
# This file defines mandatory pre-push validation checks.
# Enforced by Claude Code hooks before allowing git push.

version: "1.0"
enabled: true
bypass_flag: "--skip-push-rules"

rebase_policy:
  enforcement: strict
  base_branch: main
  allow_merge_commits: false

lint:
  required: true
  command: "uv run ruff check ."
  allow_warnings: false
  timeout: 120

test:
  required: true
  command: "uv run pytest tests/ -x -q"
  timeout: 300

branch_naming_pattern: "^(feature|fix|docs|refactor|test|chore)/[a-z0-9-]+$"
enforce_branch_naming: true

janitor_settings:
  run_after_validation: true
  prune_merged_branches: true
  clean_stale_worktrees: true
  protected_branches:
    - main
    - master
    - develop
---

# Git Push Rules

This file defines mandatory checks that must pass before pushing code to the remote repository. These rules are enforced by Claude Code hooks and help maintain code quality.

## Rebase Policy

All branches MUST be rebased on the base branch before pushing. Merge commits pollute git history and are NOT allowed.

- **Enforcement**: strict
- **Base Branch**: main
- **Allow Merge Commits**: false

> **Why?** Rebasing keeps a clean, linear git history that is easier to read, bisect, and revert. Merge commits create "bubble" patterns that obscure the actual changes.

## Validation Requirements

### Linting

Static analysis must pass before pushing. This catches style issues, unused imports, and potential bugs early.

- **Required**: true
- **Command**: `uv run ruff check .`
- **Allow Warnings**: false
- **Timeout**: 120

> **Tip**: Run `uv run ruff check . --fix` to auto-fix most issues.

### Testing

All tests must pass before pushing. This prevents broken code from reaching the remote.

- **Required**: true
- **Command**: `uv run pytest tests/ -x -q`
- **Minimum Coverage**: 0
- **Timeout**: 300

> **Note**: Set `Minimum Coverage` to 80 to enforce coverage requirements.

## Branch Naming Convention

Branch names must follow the project's naming convention for clarity and automation.

- **Pattern**: `^(feature|fix|docs|refactor|test|chore)/[a-z0-9-]+$`
- **Enforce**: true

**Valid examples**:
- `feature/add-push-rules`
- `fix/hook-timeout`
- `docs/update-readme`
- `refactor/simplify-validation`

**Invalid examples**:
- `my-branch` (missing prefix)
- `Feature/Add-Rules` (uppercase not allowed)
- `feature/add_rules` (underscores not allowed)

## Janitor Settings

Post-validation cleanup settings for the github-janitor agent.

- **Run After Validation**: true
- **Prune Merged Branches**: true
- **Clean Stale Worktrees**: true
- **Protected Branches**: main, master, develop

> **Note**: Janitor runs automatically after `/jpspec:validate` Phase 7.

---

## Customization

Edit the YAML frontmatter at the top of this file to customize rules for your project. Common customizations:

### Disable a check temporarily
```yaml
enabled: false  # Disable all push rules
```

### Use different lint command
```yaml
# For npm projects:
lint:
  command: "npm run lint"
```

### Strict coverage enforcement
```yaml
test:
  command: "uv run pytest tests/ --cov=src --cov-fail-under=80"
```

### Allow merge commits for specific repos
```yaml
rebase_policy:
  allow_merge_commits: true
```

---

*Generated by JP Spec Kit. See docs/guides/push-rules-configuration.md for details.*
"""

PENDING_CLEANUP_TEMPLATE = {
    "last_updated": None,
    "merged_branches": [],
    "orphaned_worktrees": [],
    "non_compliant_branches": {},
}


def get_template_content() -> str:
    """Get push rules template content.

    First tries to load from templates directory, falls back to embedded default.

    Returns:
        Template content as string.
    """
    # Try to find template file relative to this module
    module_dir = Path(__file__).parent.parent
    template_paths = [
        module_dir.parent.parent / "templates" / "push-rules-template.md",  # Dev
        module_dir / "templates" / "push-rules-template.md",  # Installed
    ]

    for template_path in template_paths:
        if template_path.exists():
            try:
                return template_path.read_text(encoding="utf-8")
            except OSError:
                continue

    return DEFAULT_PUSH_RULES_CONTENT


def scaffold_push_rules(
    project_root: Path,
    *,
    force: bool = False,
    template_content: Optional[str] = None,
) -> dict[str, list[Path]]:
    """Create push rules file and state directory structure.

    Args:
        project_root: Root directory of the project.
        force: If True, overwrite existing push-rules.md.
        template_content: Custom template content (for testing).

    Returns:
        Dict with 'created' and 'skipped' lists of paths.
    """
    result: dict[str, list[Path]] = {
        "created": [],
        "skipped": [],
    }

    # Create push-rules.md at project root
    push_rules_path = project_root / "push-rules.md"
    if push_rules_path.exists() and not force:
        result["skipped"].append(push_rules_path)
    else:
        content = template_content or get_template_content()
        push_rules_path.write_text(content, encoding="utf-8")
        result["created"].append(push_rules_path)

    # Create .specify/state/ directory
    state_dir = project_root / ".specify" / "state"
    state_dir.mkdir(parents=True, exist_ok=True)

    # Create janitor-last-run timestamp file
    janitor_timestamp = state_dir / "janitor-last-run"
    if janitor_timestamp.exists() and not force:
        result["skipped"].append(janitor_timestamp)
    else:
        timestamp = datetime.now(timezone.utc).isoformat()
        janitor_timestamp.write_text(timestamp, encoding="utf-8")
        result["created"].append(janitor_timestamp)

    # Create pending-cleanup.json
    pending_cleanup = state_dir / "pending-cleanup.json"
    if pending_cleanup.exists() and not force:
        result["skipped"].append(pending_cleanup)
    else:
        cleanup_state = PENDING_CLEANUP_TEMPLATE.copy()
        cleanup_state["last_updated"] = datetime.now(timezone.utc).isoformat()
        pending_cleanup.write_text(
            json.dumps(cleanup_state, indent=2), encoding="utf-8"
        )
        result["created"].append(pending_cleanup)

    # Ensure .specify/state/ is in .gitignore
    gitignore_path = project_root / ".gitignore"
    state_pattern = ".specify/state/"

    if gitignore_path.exists():
        gitignore_content = gitignore_path.read_text(encoding="utf-8")
        if state_pattern not in gitignore_content:
            # Append to .gitignore
            with gitignore_path.open("a", encoding="utf-8") as f:
                if not gitignore_content.endswith("\n"):
                    f.write("\n")
                f.write("\n# JP Spec Kit state files (auto-generated, not tracked)\n")
                f.write(f"{state_pattern}\n")
    else:
        # Create .gitignore with state directory entry
        gitignore_path.write_text(
            f"# JP Spec Kit state files (auto-generated, not tracked)\n"
            f"{state_pattern}\n",
            encoding="utf-8",
        )
        result["created"].append(gitignore_path)

    return result


def get_scaffold_summary(result: dict[str, list[Path]]) -> str:
    """Generate human-readable summary of scaffold results.

    Args:
        result: Dict from scaffold_push_rules.

    Returns:
        Summary string.
    """
    created = result.get("created", [])
    skipped = result.get("skipped", [])

    parts = []
    if created:
        parts.append(f"created {len(created)} files")
    if skipped:
        parts.append(f"skipped {len(skipped)} existing")

    return ", ".join(parts) if parts else "nothing to do"


__all__ = ["scaffold_push_rules", "get_scaffold_summary", "get_template_content"]
